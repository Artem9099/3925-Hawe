<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_SEQ_PROCESS_NEST1" Id="{90dfbb11-d3d7-48d5-bf26-d1c1660fcc54}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SEQ_PROCESS_NEST1 IMPLEMENTS I_PROCESS_NEST1
VAR_INPUT
  bDoubleActing:                                          BOOL := TRUE;
  rSpeedEfficiencyFactor:                                 REAL;
  uiRecordDelay:                                          UINT;
  
END_VAR
VAR_OUTPUT
  rMaxSpeedInMmPerSHP:                                    REAL := 50;
  rMaxSpeedInMmPerSWP:                                    REAL := 50;
END_VAR
VAR //General
	{attribute 'instance-path'} 
  {attribute 'noinit'} 
	strInstancePath:									                      STRING;
	bInit: 												                          BOOL:=TRUE;
	strFullObjectPath: 								                      STRING;
	stEvent:											                          ST_EVENT;
	bAck:												                            BOOL;
	bEnable:                                                BOOL;
END_VAR
VAR   // From FB_init	
	itfLogEvents: 										                      I_HANDLE_EVENTS;
  itfOpMode:											                        I_OP_MODE; 
  itfTimer:                                               I_CLOCK;
  itfCounterCyl:                                          I_CYLINDER_DA_COUNTER;
  itfTestCyl:                                             I_CYLINDER_DA_TESTDEV1;
  itfCounterCylPump:                                      I_PUMP_WITH_BYPASS;
  itfTestCylPump:                                         I_PUMP;
  itfPump2Pressure:                                       I_PRV_PROP;
  itfPump3Pressure:                                       I_PRV_PROP;
  itfPump4Pressure:                                       I_PRV_PROP;
END_VAR                                      				
VAR	// Step chain control                				
  eSeq, eLastSeq, eNextSeq:					                      E_SEQ_PROCESS; 
  uiSnippetSeq, uiLastSnippetSeq:                         UINT := 0;
                  				
  //eActiveSeqState, eLastActiveSeqState:                 E_SEQ_GENERAL;
	(*
  iInternalSeqStateCase, iLastInternalSeqStateCase:       INT:=0;       
	tonDelay, tonTimeOut, tonStepTime:						          TON;
	tDelay:													                        TIME := T#100MS;
	tTimeOut:												                        TIME := T#100MS;
	tTimeOutExt:											                      TIME := T#100MS;
	bDelayActive, bTimeOutActiveQuit, bTimeOutActiveNoQuit:	BOOL;//Timer Option
	bActiveStep, bDebugAcitve, bDebugNext:					        BOOL;//Debug Option
	i:														                          INT;
 	iError:													                        INT; //ERROR-CODE                    	                   		
	listLastSteps:											                    ARRAY[0..49] OF ST_LAST_STEPS;	
	strExtraInfo:											                      STRING; 
	eStep_Type:												                      E_STEP_STATE_TYPE; 
	bDebugModeActive:										                    BOOL;   
	bWaitForBreakpoint:										                  BOOL;
	bBreakpointActive:										                  BOOL;
	bDebugResume:											                      BOOL;   
	listBreakpoint:											                    ARRAY[0..10] OF  INT;    
*)
i:														                            INT;
ii:                                                       INT;
stSeqCtrlGeneral:											                    ST_SEQ_CTRL_GEN;     	
END_VAR                                             		
VAR                                                 		
	bMethodeFromExtStarted:									                BOOL;
	bMethodeFromExtActive:									                BOOL;
	bMethodeFromExtDone:									                  BOOL;
	strTemp:												                        STRING;
END_VAR   
VAR
  strSerialNr:                                            STRING;
  udiCurrentCycle:                                        UDINT := 1;
  lrLastPos:                                              LREAL;
  rTargetLowPressureInBar:                                REAL;
  // Max Speed determination
  lrTotalSpeed:                                           LREAL := 0.0;
  udiSpeedDividend:                                       UDINT := 0;
  listSpeed:                                              ARRAY [1..6] OF REAL;
END_VAR    
VAR // Input variables
  uiVentCount:                                            UINT;
  udiERCycles:                                            UDINT;
  udiERTotalCycles:                                       UDINT := 0;
  stERParams:                                             ST_RECIPE_ENDURANCE_RUN;
  stBPDParams:                                            ST_RECIPE_BREAK_PRESSURE;
  stLT1Params:                                            ST_RECIPE_LEAK_TEST1;
  stLT2Params:                                            ST_RECIPE_LEAK_TEST2;
  uiCurrentNokLimitInPercent:                             UINT;
  rCurrentNokDifference:                                  REAL;
  lrStartVal:                                             LREAL;
  sTimer:                                                 STRING;
END_VAR          	
VAR_TEMP                    	
	iTemp:											                            INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Set FBs and Interfaces ready after switch internal step
IF stSeqCtrlGeneral.iInternalSeqStateCase <> stSeqCtrlGeneral.iLastInternalSeqStateCase AND NOT stSeqCtrlGeneral.bExitSetReadyState THEN
  uiSnippetSeq := 0;
  stSeqCtrlGeneral.bExitSetReadyState := TRUE
                                         AND itfCounterCyl.M_SetReady()
                                         AND itfTestCyl.M_SetReady()
                                         AND itfCounterCylPump.M_SetReady()
                                         AND itfTestCylPump.M_SetReady()
                                         AND uiSnippetSeq = 0;
  IF TRUE
  AND (stERParams.rSpeedA > THIS^.rMaxSpeedInMmPerSWP * THIS^.rSpeedEfficiencyFactor
  OR stERParams.rSpeedB > THIS^.rMaxSpeedInMmPerSHP * THIS^.rSpeedEfficiencyFactor)
  THEN
    stSeqCtrlGeneral.bExitSetReadyState := TRUE
                                           AND itfPump2Pressure.M_SetReady()
                                           AND itfPump3Pressure.M_SetReady()
                                           AND itfPump4Pressure.M_SetReady();
  END_IF
  IF NOT stSeqCtrlGeneral.bExitSetReadyState THEN 
    RETURN; 
  END_IF
END_IF

stSeqCtrlGeneral.strObject := F_CreateObjectName(strInstancePath);
sTimer := itfTimer.M_GetTimerET(bCustomFormat:= FALSE, sFormat:= '');

// First method call
_m_SequenceManager();
//_m_SaveLastStep();

CASE eSeq OF 
  E_SEQ_VALVE.BASE:;
  
	E_SEQ_PROCESS.INIT: _m_Seq_INIT();
		IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
		
	E_SEQ_PROCESS.SETUP:;
  
	// Process
	E_SEQ_PROCESS.MEASURE_STROKE_LENGTH: _m_Seq_MEASURE_STROKE_LENGTH();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.VENT_CYLINDER: _m_Seq_VENT_CYLINDER();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.MOVE_TO_SET_POS: _m_Seq_MOVE_TO_SET_POS();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.BREAK_PRESSURE_DET: _m_Seq_BREAK_PRESSURE_DET();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.LEAK_TEST_1: _m_Seq_LEAK_TEST_1();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.LEAK_TEST_2: _m_Seq_LEAK_TEST_2();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
  
  E_SEQ_PROCESS.ENDURANCE_RUN: _m_Seq_ENDURANCE_RUN();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
    
  E_SEQ_PROCESS.MAX_SPEED_RECORD: _m_Seq_MAX_SPEED_RECORD();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
      eSeq := eNextSeq := E_SEQ_PROCESS.BASE;
		END_IF

  E_SEQ_PROCESS.STOP_ENGINE: _m_Seq_STOP_ENGINE();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
    
  E_SEQ_PROCESS.STOP: _m_Seq_STOP();
    IF TRUE
		AND (stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE) 
		THEN
			eSeq := E_SEQ_PROCESS.BASE;
		END_IF
    
  // End
	E_SEQ_PROCESS.END:;
	E_SEQ_PROCESS.ERROR_SEQ:;	
END_CASE

strTemp:=TO_STRING(eSeq);]]></ST>
    </Implementation>
    <Folder Name="PRIVAT" Id="{ce939ec0-3583-4ef0-acbf-ed0b7b898ead}" />
    <Folder Name="SEQUNCE" Id="{f2150bd3-0134-4d74-aab9-eac5b43c1e35}">
      <Folder Name="SEQ_SNIPPETS" Id="{496cfef1-3e61-4f07-a73c-53ef43c4f71f}" />
    </Folder>
    <Method Name="_m_DebugManager" Id="{6dde5c5c-c073-4f58-ac83-65bda3e7d299}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD PRIVATE _m_DebugManager
VAR_INPUT
	iStepID: int;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF TRUE
AND THIS^.stSeqCtrlGeneral.bDebugModeActive 
AND NOT THIS^.stSeqCtrlGeneral.bActiveStep
THEN


THIS^.stSeqCtrlGeneral.bBreakpointActive:=FALSE;

FOR i:=0 TO 10 DO
	
	IF TRUE
	AND iStepID=THIS^.stSeqCtrlGeneral.listBreakpoint[i] 
	AND iStepID<>0
	THEN
		EXIT;
	END_IF
END_FOR
IF (i<=10) THEN
	THIS^.stSeqCtrlGeneral.bBreakpointActive:=TRUE;
END_IF

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Delay" Id="{afe32a0d-66df-45f4-aefa-508e58f789d5}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD _m_Delay : BOOL
VAR_INPUT
	DelayTime:	TIME;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stSeqCtrlGeneral.bDelayActive := TRUE;
THIS^.stSeqCtrlGeneral.tDelay := DelayTime;

_m_Delay := THIS^.stSeqCtrlGeneral.tonDelay.Q;]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_GeneralStepSetting" Id="{038b80d8-386d-4d3f-be70-faba59a8c5b7}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD PRIVATE _m_GeneralStepSetting : BOOL
VAR_INPUT
	StepType:			    	E_STEP_STATE_TYPE;
	InfoTextID:					STRING(20);
	EnableDebug:	   			BOOL;	
	
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.stSeqCtrlGeneral.bActiveStep THEN
	THIS^.stSeqCtrlGeneral.eStep_Type:=StepType;
	THIS^.stSeqCtrlGeneral.strExtraInfo:= GenLib.F_RET_TXTLIST_ENTRY(strPortNr:='851',strID:='',strTxtLstName:=InfoTextID);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_LeakTest1_LeakDet" Id="{5c47bccd-e780-415c-8749-c36cf9672895}" FolderPath="SEQUNCE\SEQ_SNIPPETS\">
      <Declaration><![CDATA[METHOD PRIVATE _m_LeakTest1_LeakDet : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_m_LeakTest1_LeakDet := THIS^.uiSnippetSeq = 999;

IF TRUE 
AND THIS^.uiSnippetSeq <> THIS^.uiLastSnippetSeq 
THEN
  IF NOT _m_ResetDelayTimer() THEN
    RETURN;
	END_IF
END_IF

THIS^.uiLastSnippetSeq := THIS^.uiSnippetSeq;

CASE THIS^.uiSnippetSeq OF
  0:
    IF TRUE
    AND _m_ResetDelayTimer()
		THEN 
      THIS^.uiSnippetSeq := 10;
		END_IF
  
  10:
    IF TRUE
    AND _m_Delay(DelayTime:= UINT_TO_TIME(THIS^.uiRecordDelay * 1000))
		THEN 
      THIS^.lrStartVal := THIS^.itfTestCyl.P_Position;
      THIS^.uiSnippetSeq := 20;
		END_IF
    
  20:
    IF TRUE
    AND _m_Delay(DelayTime:= UDINT_TO_TIME(THIS^.stLT1Params.udiDurationPerTest * 60000))
		THEN 
      THIS^.uiSnippetSeq := 999;
		END_IF
    IF ABS(THIS^.lrStartVal - THIS^.itfTestCyl.P_Position) > ABS(THIS^.stLT1Params.rNokLimit) THEN
      THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; // Abort
		END_IF
    THIS^.rCurrentNokDifference := ABS(THIS^.lrStartVal - THIS^.itfTestCyl.P_Position);
    THIS^.uiCurrentNokLimitInPercent := TO_UINT(100 / ABS(THIS^.stLT1Params.rNokLimit) * THIS^.rCurrentNokDifference);
END_CASE



]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_LeakTest2_LeakDet" Id="{ff710211-1f4f-4c67-b969-3bd02710574d}" FolderPath="SEQUNCE\SEQ_SNIPPETS\">
      <Declaration><![CDATA[METHOD PRIVATE _m_LeakTest2_LeakDet : BOOL
VAR_INPUT
END_VAR
VAR
  rV0:        REAL := 75;
  rTmpVal:    REAL;
END_VAR

// Formula for Leak Test 2
// V0 Speicher = 75 cm³ (ml)
// P0 Speicher = 95 bar
// P2 (Anfangsdruck) = 354.4 bar
// P1 (Enddruck) = 353.7 bar
// Ergebnis = 0.01 cm³ (ml)

// DeltaV = V0 * SQRT((P0 / P2) * ((P2 / P1) - 1))]]></Declaration>
      <Implementation>
        <ST><![CDATA[_m_LeakTest2_LeakDet := THIS^.uiSnippetSeq = 999;

IF TRUE 
AND THIS^.uiSnippetSeq <> THIS^.uiLastSnippetSeq 
THEN
  IF NOT _m_ResetDelayTimer() THEN
    RETURN;
	END_IF
END_IF

THIS^.uiLastSnippetSeq := THIS^.uiSnippetSeq;

CASE THIS^.uiSnippetSeq OF
  0:
    IF TRUE
    AND _m_ResetDelayTimer()
		THEN 
      THIS^.uiSnippetSeq := 10;
		END_IF
  
  10:
    IF TRUE
    AND _m_Delay(DelayTime:= UINT_TO_TIME(THIS^.uiRecordDelay * 1000))
		THEN 
      THIS^.lrStartVal := THIS^.itfTestCyl.P_ReservoirPressure;
      THIS^.uiSnippetSeq := 20;
		END_IF
    
  20:
    IF TRUE
		THEN 
      IF THIS^.lrStartVal <= 0 THEN
        THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
      ELSE
        THIS^.uiSnippetSeq := 30;
      END_IF
		END_IF
    
  30:
    IF TRUE
    AND _m_Delay(DelayTime:= UDINT_TO_TIME(THIS^.stLT2Params.udiDurationPerTest * 60000))
		THEN 
      THIS^.uiSnippetSeq := 999;
		END_IF
    IF ABS(THIS^.rCurrentNokDifference) > ABS(THIS^.stLT1Params.rNokLimit) THEN
      //THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; // Abort
		END_IF
    rTmpVal := (112 / THIS^.lrStartVal) * ((THIS^.lrStartVal / THIS^.itfTestCyl.P_ReservoirPressure) - 1);
    IF ABS(rTmpVal) > 0 THEN
      THIS^.rCurrentNokDifference := ABS(75 * SQRT(rTmpVal));
    ELSE
      THIS^.rCurrentNokDifference := 0;
    END_IF
    THIS^.uiCurrentNokLimitInPercent := TO_UINT(100 / ABS(THIS^.stLT1Params.rNokLimit) * THIS^.rCurrentNokDifference);
END_CASE



]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_ResetDelayTimer" Id="{a87074ad-9f2e-405d-8180-62d94d4076fc}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD _m_ResetDelayTimer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_m_ResetDelayTimer := THIS^.stSeqCtrlGeneral.tonDelay.ET = T#0MS;

THIS^.stSeqCtrlGeneral.tonDelay(IN:= FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_SaveLastStep" Id="{e41416f1-2e51-4f4f-93c3-d4800a11b7eb}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD PRIVATE _m_SaveLastStep : BOOL
VAR_INPUT
END_VAR
VAR
	i: dint;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT THIS^.stSeqCtrlGeneral.bActiveStep THEN
	
	FOR i:=49 TO 1 BY -1 DO
			stSeqCtrlGeneral.listLastSteps[i].strStepName:=stSeqCtrlGeneral.listLastSteps[i-1].strStepName;
			stSeqCtrlGeneral.listLastSteps[i].tStepTime:=stSeqCtrlGeneral.listLastSteps[i-1].tStepTime;
			stSeqCtrlGeneral.listLastSteps[i].tDelayTime:=stSeqCtrlGeneral.listLastSteps[i-1].tDelayTime;
	END_FOR
	stSeqCtrlGeneral.listLastSteps[0].strStepName:=TO_STRING(THIS^.eSeq);
	stSeqCtrlGeneral.listLastSteps[1].tStepTime:=THIS^.stSeqCtrlGeneral.tonStepTime.ET;
	stSeqCtrlGeneral.listLastSteps[1].tStepTime:=THIS^.stSeqCtrlGeneral.tonDelay.ET;
ELSE
	stSeqCtrlGeneral.listLastSteps[0].tStepTime:=THIS^.stSeqCtrlGeneral.tonStepTime.ET;
	stSeqCtrlGeneral.listLastSteps[0].tDelayTime:=THIS^.stSeqCtrlGeneral.tonDelay.ET;	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_BREAK_PRESSURE_DET" Id="{62833b11-a24b-44c4-945c-c34b179e5b9d}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_BREAK_PRESSURE_DET : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq:    STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF

    10: // Disable low pressure mode
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
        END_IF
			END_IF
      
    50:	// Move test cylinder to HP
      IF TRUE  
      AND _m_Delay(DelayTime:= T#3S)
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
      AND THIS^.itfTestCyl.P_Position <= THIS^.stBPDParams.rEndPosTol
      AND THIS^.itfTestCyl.P_SpeedInMmPerSecond < 0.1
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60;
			END_IF
      
    60:	// Stop
      IF TRUE  
      AND THIS^.itfTestCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70;
			END_IF
      
    70:	// Set work pressure zero
      IF TRUE  
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
			END_IF
      
		80:	// Open low pressure valve, set limit zero and move counter cylinder to HP
      IF TRUE 
      AND _m_Delay(DelayTime:= T#10S)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
      AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= TRUE, ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.rTargetLowPressureInBar := THIS^.stBPDParams.rIncreaseValueInBar;
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90;
			END_IF
      
    90:	// Stop counter cylinder
      IF TRUE 
      AND _m_Delay(T#1S)
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
			END_IF
  
		100:	// Move test cylinder to WP
      IF TRUE 
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 100, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 110; 
			END_IF
      
    110:	// Set pressure
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= TRUE, ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= THIS^.rTargetLowPressureInBar)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120; 
			END_IF
      
    120:	// Increase time
      IF TRUE 
			AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stBPDParams.rIncreaseInterval * 1000))
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 121; 
			END_IF
      
    121:	// Check if cylinder moving or in end position
      IF TRUE 
			AND ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond) < ABS(THIS^.stBPDParams.rMinSpeedInMmPerS)
      AND THIS^.itfTestCyl.P_Position < THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stBPDParams.rEndPosTol)
			THEN 
        THIS^.rTargetLowPressureInBar := THIS^.rTargetLowPressureInBar + ABS(THIS^.stBPDParams.rIncreaseValueInBar);
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 110; 
      ELSIF TRUE 
			AND ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond) < ABS(THIS^.stBPDParams.rMinSpeedInMmPerS)
      AND THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stBPDParams.rEndPosTol)
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 130; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120; 
			END_IF
      
    130:  // Check if test reverse break pressure or exit sequence
      IF TRUE
      AND THIS^.bDoubleActing 
      AND THIS^.itfTestCyl.P_Position > THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stBPDParams.rEndPosTol + 5) 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 200; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    (*Testing double acting cylinder to HP*)
    200:	// Stop
      IF TRUE  
      AND THIS^.itfTestCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 210;
			END_IF
      
		210:	// Set limit zero
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
      AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= TRUE, ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.rTargetLowPressureInBar := THIS^.stBPDParams.rIncreaseValueInBar;
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 220;
			END_IF
  
		220:	// Move test cylinder to HP
      IF TRUE 
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 100, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 230; 
			END_IF
      
    230:	// Set pressure
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= TRUE, ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= THIS^.rTargetLowPressureInBar)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 240; 
			END_IF
      
    240:	// Increase time
      IF TRUE 
			AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stBPDParams.rIncreaseInterval * 1000))
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 241; 
			END_IF
      
    241:	// Check if cylinder moving or in end position
      IF TRUE 
			AND ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond) < ABS(THIS^.stBPDParams.rMinSpeedInMmPerS)
      AND THIS^.itfTestCyl.P_Position > ABS(THIS^.stBPDParams.rEndPosTol)
			THEN 
        THIS^.rTargetLowPressureInBar := THIS^.rTargetLowPressureInBar + ABS(THIS^.stBPDParams.rIncreaseValueInBar);
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 230; 
      ELSIF TRUE 
			AND ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond) < ABS(THIS^.stBPDParams.rMinSpeedInMmPerS)
      AND THIS^.itfTestCyl.P_Position <= ABS(THIS^.stBPDParams.rEndPosTol)
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 240; 
			END_IF
      
    1000: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF
      
    1010: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_ENDURANCE_RUN" Id="{96da3796-7539-4ef3-9c47-5e14e70b0c04}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_ENDURANCE_RUN : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq:            STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
    THIS^.udiCurrentCycle := 1;
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
    
		10: // Disable low pressure mode
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN
        IF TRUE
        AND (THIS^.stERParams.rSpeedA > THIS^.rMaxSpeedInMmPerSWP * THIS^.rSpeedEfficiencyFactor
        OR THIS^.stERParams.rSpeedB > THIS^.rMaxSpeedInMmPerSHP * THIS^.rSpeedEfficiencyFactor) 
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 11; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 15; 
				END_IF
			END_IF
      
    11: // Add pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= TRUE)
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 100)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 12; 
			END_IF
      
    12: // Add pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= TRUE)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 100)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 13; 
			END_IF
      
    13: // Add pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= TRUE)
      AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 100)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 15; 
			END_IF

    15: // Choice step
      IF TRUE 
			THEN 
        IF TRUE
        AND THIS^.udiCurrentCycle > THIS^.udiERCycles 
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
				END_IF
			END_IF
      
    20: // Add low pressure circuit to counter cylinder
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Stop
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stERParams.rDelay * 1000))
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Move to WP (Max position - 10)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stERParams.rWorkForceA * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.MM_PER_SECOND, 
                                  rSpeed:= THIS^.stERParams.rSpeedA)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 41;
			END_IF
      
    41: // Move to WP (Max position - 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToWP( ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                      rWorkPressure:= THIS^.stERParams.rLoadForceA * 1000, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50;
			END_IF
      
    50: // Move to WP (Max position - 10)
      IF TRUE
			THEN 
        IF THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stERParams.rTurningPointWP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
        END_IF
			END_IF
      
    60: // Stop
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stERParams.rDelay * 1000))
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
			END_IF
      
    70: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stERParams.rWorkForceB * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.MM_PER_SECOND, 
                                  rSpeed:= THIS^.stERParams.rSpeedB)
			THEN 
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 71;
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 72;
        END_IF
			END_IF
      
    71: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToHP( ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                      rWorkPressure:= THIS^.stERParams.rLoadForceB * 1000, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
			END_IF
      
    72: // Move to WP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToWP( ePressureType:= E_PRESSURE_TYPE.BAR, 
                                      rWorkPressure:= 200, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
			END_IF
      
    80: // Move to WP (Min position + 10)
      IF TRUE
			THEN 
        IF THIS^.itfTestCyl.P_Position <= ABS(THIS^.stERParams.rTurningPointHP) THEN
          THIS^.udiCurrentCycle := THIS^.udiCurrentCycle + 1;
          THIS^.udiERTotalCycles := THIS^.udiERTotalCycles + 1;
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 15; // Jump backward
        END_IF
			END_IF
      
    1000: // Exit seq - Disable low pressure circuit
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF  
      
    1010: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1020;
			END_IF
      
    1020: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1030; 
			END_IF
      
    1030: // Remove pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1040; 
			END_IF
      
    1040: // Remove pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1050; 
			END_IF
      
    1050: // Remove pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
			THEN
        IF TRUE
        AND (THIS^.stERParams.rSpeedA > THIS^.rMaxSpeedInMmPerSWP * THIS^.rSpeedEfficiencyFactor
        OR THIS^.stERParams.rSpeedB > THIS^.rMaxSpeedInMmPerSHP * THIS^.rSpeedEfficiencyFactor) 
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1060; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
        END_IF
			END_IF
      
    1060: // Set Pressure to zero
      IF TRUE 
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));

E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_INIT" Id="{a9142b2c-1e9e-4055-8d33-4b876d6fbade}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_INIT : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
	ActiveSeq: STRING;
END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
    THIS^.udiERTotalCycles := 0;
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0:  // Switch off the counter and test pump
      IF TRUE 
			AND THIS^.itfCounterCylPump.M_Off()
      AND THIS^.itfTestCylPump.M_Off()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
			END_IF
      
    10: // Enable counter and low pressure pump bypass
      IF TRUE 
			AND THIS^.itfCounterCylPump.M_Bypass(bEnable:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
			END_IF
      
		50:	// Reset counter cylinder
      IF TRUE 
			AND THIS^.itfCounterCyl.M_Reset()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
			END_IF
      
		60: // Reset test cylinder
      IF TRUE 
			AND THIS^.itfTestCyl.M_Reset()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
			END_IF
      
		70: // Turn on the counter, test and low pressure pump
      IF TRUE 
			AND THIS^.itfCounterCylPump.M_On() 
      AND THIS^.itfTestCylPump.M_On()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit step
      IF TRUE
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999;
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_LEAK_TEST_1" Id="{c54d89d0-d41c-405d-9754-87366b650af0}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_LEAK_TEST_1 : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
		0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF

    10: // Disable low pressure mode and enable bypass to low pressure pump
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Shut off low pressure circuit to counter cylinder and switch off pump
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      //AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      //AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
			END_IF
      
    50: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      //AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 61; 
        END_IF
			END_IF
      
    60: // Move to HP (Min position + 10mm)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= ABS(THIS^.stLT1Params.rDistanceBeforeEndPosHP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
        END_IF
			END_IF
      
    61: // Move to HP (Min position + 10mm)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 10, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= ABS(THIS^.stLT1Params.rDistanceBeforeEndPosHP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
        END_IF
			END_IF
      
    70: // Stop and lock
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80; 
			END_IF
      
    80: // Set cylinder pressure to 0
      IF TRUE
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90; 
			END_IF
      
    90: // Start leak test push (HP endposition + 10mm)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceA * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
			END_IF
      
    100: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 110;
			END_IF
      
    110: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT1Params.rRestDelay * 1000))
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120; 
			END_IF
      
    120: // Start leak test pull (HP endposition + 10mm)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceB * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 130;
			END_IF
      
    130: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 140;
			END_IF
      
    140: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT1Params.rRestDelay))
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 150; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 151; 
        END_IF
			END_IF
      
    150: // Move to WP (Max position - 10mm)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stLT1Params.rDistanceBeforeEndPosWP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 160; 
        END_IF
			END_IF
      
    151: // Move to WP (Max position - 10mm)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 10, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stLT1Params.rDistanceBeforeEndPosWP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 160; 
        END_IF
			END_IF
      
    160: // Stop and lock
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 170; 
			END_IF
      
    170: // Set cylinder pressure to 0
      IF TRUE
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 180; 
			END_IF
      
    180: // Start leak test push (WP endposition - 10mm)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceA * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 190;
			END_IF
      
    190: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 200;
			END_IF
      
    200: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT1Params.rRestDelay * 1000))
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 210; 
			END_IF
      
    210: // Start leak test pull (WP endposition - 10mm)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceB * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 220;
			END_IF
      
    220: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 230;
			END_IF
      
    230: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT1Params.rRestDelay * 1000))
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 240; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 241; 
        END_IF
			END_IF
      
    240: // Move to Middle position
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= THIS^.itfTestCyl.P_StrokeLength / 2 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 250; 
        END_IF
			END_IF
      
    241: // Move to Middle position
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 10, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= THIS^.itfTestCyl.P_StrokeLength / 2 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 250; 
        END_IF
			END_IF
      
    250: // Stop and lock
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 260; 
			END_IF
      
    260: // Set cylinder pressure to 0
      IF TRUE
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 270; 
			END_IF
      
    270: // Start leak test push (Middle position)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceA * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 280;
			END_IF
      
    280: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 290;
			END_IF
      
    290: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT1Params.rRestDelay * 1000))
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 300; 
			END_IF
      
    300: // Start leak test pull (Middle position)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                     rWorkPressure:= THIS^.stLT1Params.rLoadForceB * 1000, 
                                     eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                     rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 310;
			END_IF
      
    310: // Leak detection
      IF TRUE
      AND _m_LeakTest1_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 320;
			END_IF
      
    320: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= T#5S)
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit seq - Disable low pressure circuit
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF
      
    1010: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1020;
			END_IF
      
    1020: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_LEAK_TEST_2" Id="{6897bcaa-75b5-4351-b4fd-3691679d9dcb}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_LEAK_TEST_2 : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
		0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF

    10: // Disable low pressure mode
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Disable low pressure mode
      IF TRUE 
			//AND THIS^.itfTestCyl.M_OpenReservoir(bOpenA:= TRUE, bOpenB:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
			END_IF
      
    50: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
			END_IF
      
    60: // Shut off low pressure circuit to counter cylinder and switch off pump
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
        IF THIS^.bDoubleActing THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120;
        END_IF
			END_IF
      
    70: // Move to HP (Min position)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= 0.1 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80; 
        END_IF
			END_IF
      
    80: // Stop and lock
      IF TRUE
      AND _m_Delay(DelayTime:= T#3S)
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90; 
			END_IF
      
    90: // Set cylinder pressure to 0
      IF TRUE
      AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_OpenReservoir(bOpenA:= TRUE, bOpenB:= FALSE)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100; 
			END_IF
      
    100: // Start leak test push (HP endposition)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stLT2Params.rLoadForceB * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                  rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 110;
			END_IF
      
    110: // Set lock valves
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_OpenLockValves(bOpenChA:= FALSE, bOpenChB:= TRUE)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120;
			END_IF
      
    120: // Leak detection
      IF TRUE
      AND _m_LeakTest2_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 130;
			END_IF
      
    130: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= REAL_TO_TIME(THIS^.stLT2Params.rRestDelay * 1000))
      AND THIS^.itfTestCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 140; 
			END_IF
      
    140: // Move to WP (Max position)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - 0.1 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 150; 
        END_IF
			END_IF
      
    150: // Stop and lock
      IF TRUE
      AND _m_Delay(DelayTime:= T#3S)
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 160; 
			END_IF
      
    160: // Set cylinder pressure to 0
      IF TRUE
      AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_OpenReservoir(bOpenA:= FALSE, bOpenB:= TRUE)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 170; 
			END_IF
      
    170: // Start leak test push (WP endposition)
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stLT2Params.rLoadForceA * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                  rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 180;
			END_IF
      
    180: // Set lock valves
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_OpenLockValves(bOpenChA:= TRUE, bOpenChB:= FALSE)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 190;
			END_IF
      
    190: // Leak detection
      IF TRUE
      AND _m_LeakTest2_LeakDet()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 200;
			END_IF
      
    200: // Stop and delay
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit seq - Disable low pressure circuit
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF
      
    1010: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1020;
			END_IF
      
    1020: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1030; 
			END_IF
      
    1030: // Disable reservoir
      IF TRUE 
      AND THIS^.itfTestCyl.M_OpenReservoir(bOpenA:= FALSE, bOpenB:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_MAX_SPEED_RECORD" Id="{48988e03-87b7-4896-ae86-2c4217c6b7ae}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_MAX_SPEED_RECORD : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq:            STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
    THIS^.udiCurrentCycle := 1;
    THIS^.lrTotalSpeed := 0.0;
    THIS^.udiSpeedDividend := 0;
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      AND THIS^.itfTestCyl.P_StrokeLength - 60 > 50
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
    
		10: // Disable low pressure mode
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20;
			END_IF
      
    20: // Add low pressure circuit to counter cylinder
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stERParams.rWorkForceB * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                  rSpeed:= 100)
			THEN 
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 31;
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 32;
        END_IF
			END_IF
      
    31: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToHP( ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                      rWorkPressure:= THIS^.stERParams.rLoadForceB * 1000, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40;
			END_IF
      
    32: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToWP( ePressureType:= E_PRESSURE_TYPE.BAR, 
                                      rWorkPressure:= 200, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40;
			END_IF
      
    40: // Move to HP (Min position + 10)
      IF TRUE
			THEN 
        IF THIS^.itfTestCyl.P_Position <= ABS(THIS^.stERParams.rTurningPointHP) THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50;
        END_IF
			END_IF
      
    50: // Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 55; 
			END_IF

    55: // Choice step
      IF TRUE 
			THEN 
        IF TRUE
        AND THIS^.udiCurrentCycle > 3 
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100; // Save and exit
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
				END_IF
			END_IF
      
    60: // Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
			END_IF
      
    70: // Move to WP (Max position - 10)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stERParams.rWorkForceA * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                  rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 71;
			END_IF
      
    71: // Move to WP (Max position - 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToWP( ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                      rWorkPressure:= THIS^.stERParams.rLoadForceA * 1000, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position >= 30 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 72; 
        END_IF
			END_IF
      
    72: // Start record
      IF TRUE
      AND THIS^.itfTestCyl.P_Position <= THIS^.itfTestCyl.P_StrokeLength - 30
			THEN 
        THIS^.lrTotalSpeed := THIS^.lrTotalSpeed + ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond);
        THIS^.udiSpeedDividend := THIS^.udiSpeedDividend + 1;
      ELSE
        THIS^.listSpeed[THIS^.udiCurrentCycle] := THIS^.lrTotalSpeed / THIS^.udiSpeedDividend;
        THIS^.lrTotalSpeed := 0.0;
        THIS^.udiSpeedDividend := 0;
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 73;
			END_IF
      
    73: // Move to WP (Max position - 10)
      IF TRUE
      AND THIS^.itfTestCyl.P_Position >= THIS^.itfTestCyl.P_StrokeLength - ABS(THIS^.stERParams.rTurningPointWP) THEN
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
			END_IF
      
    80: // Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfTestCyl.M_Stop()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90; 
			END_IF
      
    90: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                  rWorkPressure:= THIS^.stERParams.rWorkForceB * 1000, 
                                  eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                  rSpeed:= 100)
			THEN 
        IF THIS^.bDoubleActing THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 91;
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 92;
        END_IF
			END_IF
      
    91: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToHP( ePressureType:= E_PRESSURE_TYPE.FORCE, 
                                      rWorkPressure:= THIS^.stERParams.rLoadForceB * 1000, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= THIS^.itfTestCyl.P_StrokeLength - 30 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 95;
        END_IF
			END_IF
      
    92: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfCounterCyl.M_ToWP( ePressureType:= E_PRESSURE_TYPE.BAR, 
                                      rWorkPressure:= 200, 
                                      eSpeedType:= E_SPEED_TYPE.PERCENT, 
                                      rSpeed:= 100)
			THEN 
        IF THIS^.itfTestCyl.P_Position <= THIS^.itfTestCyl.P_StrokeLength - 30 THEN
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 95;
        END_IF
			END_IF
      
    95: // Start record
      IF TRUE
      AND THIS^.itfTestCyl.P_Position >= 30
			THEN 
        THIS^.lrTotalSpeed := THIS^.lrTotalSpeed + ABS(THIS^.itfTestCyl.P_SpeedInMmPerSecond);
        THIS^.udiSpeedDividend := THIS^.udiSpeedDividend + 1;
      ELSE
        THIS^.listSpeed[THIS^.udiCurrentCycle + 3] := THIS^.lrTotalSpeed / THIS^.udiSpeedDividend;
        THIS^.lrTotalSpeed := 0.0;
        THIS^.udiSpeedDividend := 0;
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 96;
			END_IF
      
    96: // Move to HP (Min position + 10)
      IF TRUE
      AND THIS^.itfTestCyl.P_Position <= ABS(THIS^.stERParams.rTurningPointHP) THEN
        THIS^.udiCurrentCycle := THIS^.udiCurrentCycle + 1;
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 55; // Jump backward
			END_IF
      
    100: // Set max speed
      IF TRUE
      THEN
        FOR THIS^.ii := 1 TO 3 BY 1 DO
          IF THIS^.ii = 1 THEN
            THIS^.rMaxSpeedInMmPerSHP := THIS^.listSpeed[THIS^.ii + 3];
            THIS^.rMaxSpeedInMmPerSWP := THIS^.listSpeed[THIS^.ii];
          ELSE
            IF THIS^.rMaxSpeedInMmPerSHP > THIS^.listSpeed[THIS^.ii + 3] THEN
              THIS^.rMaxSpeedInMmPerSHP := THIS^.listSpeed[THIS^.ii + 3];
						END_IF
            IF THIS^.rMaxSpeedInMmPerSWP > THIS^.listSpeed[THIS^.ii] THEN
              THIS^.rMaxSpeedInMmPerSWP := THIS^.listSpeed[THIS^.ii];
						END_IF
					END_IF
        END_FOR  
        IF THIS^.ii >= 3 THEN
          THIS^.ii := 1;
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000;
				END_IF
			END_IF
      
    1000: // Exit seq - Disable low pressure circuit
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF  
      
    1010: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1020;
			END_IF
      
    1020: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1030; 
			END_IF
      
    1030: // Remove pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      //AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1040; 
			END_IF
      
    1040: // Remove pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      //AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1050; 
			END_IF
      
    1050: // Remove pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      //AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));

E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_MEASURE_STROKE_LENGTH" Id="{012e8b0c-05db-43ea-9194-d5dfec17b388}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_MEASURE_STROKE_LENGTH : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;
	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
  
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
		0: // Disable low pressure mode and add low pressure to counter cylinder
      IF TRUE 
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
			END_IF
      
    10: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      //AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      //AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      //AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Check if double- or single-acting cylinder
      IF TRUE 
      AND THIS^.bDoubleActing
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50;
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 51;
			END_IF
      
		50:	// Double acting cylinder - Move to HP
      IF TRUE 
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 250, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 50)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60;
			END_IF
      
    51:	// Single acting cylinder - Move to HP
      IF TRUE 
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 50)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60;
			END_IF
      
    60:	// Delay timer
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 61;
			END_IF
      
    61:	// Wait for HP endpos
      IF TRUE 
			THEN 
        IF TRUE 
        AND ABS(THIS^.itfTestCyl.P_PositionAbs - THIS^.lrLastPos) < 0.1
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70;
        ELSE
          THIS^.lrLastPos := THIS^.itfTestCyl.P_PositionAbs;
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60;
        END_IF
			END_IF
      
    70:	// Set zero position
      IF TRUE 
      AND THIS^.itfTestCyl.M_SetZeroPos()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
			END_IF
      
    80:	// Move to WP
      IF TRUE 
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 250, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90;
			END_IF
      
    90:	// Delay timer
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 91;
			END_IF
      
    91:	// Wait for WP endpos
      IF TRUE 
			THEN 
        IF TRUE 
        AND ABS(THIS^.itfTestCyl.P_PositionAbs - THIS^.lrLastPos) < 0.1
        THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
        ELSE
          THIS^.lrLastPos := THIS^.itfTestCyl.P_PositionAbs;
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90;
        END_IF
			END_IF
      
    100:	// Set Max position
      IF TRUE 
      AND THIS^.itfTestCyl.M_SetMaxPos()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 110;
			END_IF
      
    110:	// Stop
      IF TRUE 
      AND THIS^.itfCounterCyl.M_Stop()
      AND THIS^.itfTestCyl.M_StopAndLock()
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 120;
			END_IF
      
    120:	// Set work/load pressure
      IF TRUE 
      AND itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0) 
      AND itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 130;
			END_IF
      
    130: // Disable low pressure mode
      IF TRUE 
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit step
      IF TRUE
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999;
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo:=concat('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo:= 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.ERROR;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_MOVE_TO_SET_POS" Id="{670656ca-e7b2-456b-855c-d91198c2b545}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_MOVE_TO_SET_POS : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
		0:	// Entrance step
      IF TRUE 
			AND _m_Delay(T#2S)
			AND THIS^.itfTestCyl.M_ToSetPos(0,0,0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
			END_IF
      
		10: // Step 10
      IF TRUE 
			AND _m_Delay(T#2S) 
			//AND
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
		20: // Step 20
      IF TRUE 
			AND _m_Delay(T#2S) 
			//AND
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
		30:	// Step 30
      IF TRUE 
			AND _m_Delay(T#2S) 
			//AND
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit step
      IF TRUE
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999;
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_STOP" Id="{9a676912-6d4e-4b69-b51b-55e17b73a609}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_STOP : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
  IF TRUE
	THEN
    THIS^.udiCurrentCycle := 1;
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
			END_IF
      
    10: // Disable low pressure circuit to counter cylinder
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Vent cylinder - Move to WP (Max position)
      IF TRUE
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
			END_IF
      
    50: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit step
      IF TRUE
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999;
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo:=concat('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo:= 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.ERROR;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_STOP_ENGINE" Id="{4c4945d1-3687-4837-9b96-e6776498e09a}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_STOP_ENGINE : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
	ActiveSeq: STRING;
END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

	
E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
  
	IF TRUE
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
		0:  // Switch off the counter cylinder pump
      IF TRUE 
			AND THIS^.itfCounterCylPump.M_Off()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
			END_IF
      
    10: // Enable bypass
      IF TRUE 
			AND THIS^.itfCounterCylPump.M_Bypass(bEnable:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Switch off the test cylinder pump
      IF TRUE 
			AND THIS^.itfTestCylPump.M_Off()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
			END_IF
      
    1000: // Exit step
      IF TRUE
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999;
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo := CONCAT('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo := 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.ERROR;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Seq_VENT_CYLINDER" Id="{c271dbf5-0286-487c-b56f-f3ee96d719bd}" FolderPath="SEQUNCE\">
      <Declaration><![CDATA[METHOD PRIVATE _m_Seq_VENT_CYLINDER : E_SEQ_PROCESS
VAR_INPUT
END_VAR
VAR
  ActiveSeq: STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//THIS^._m_GeneralStepSetting(StepType:=E_STEP_STATE_TYPE.INIT,
ActiveSeq := TO_STRING(THIS^.eSeq);

CASE THIS^.stSeqCtrlGeneral.eActiveSeqState OF
E_SEQ_GENERAL.READY:;

E_SEQ_GENERAL.EXECUTE:;
	IF TRUE
	AND _m_Delay(T#1S)
	THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.RESET;
	END_IF
  
E_SEQ_GENERAL.RESET:;
	stSeqCtrlGeneral.iInternalSeqStateCase := 0;
  IF TRUE
	THEN
    THIS^.udiCurrentCycle := 1;
		THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.BUSY;
	END_IF
  
E_SEQ_GENERAL.BUSY:;
	CASE THIS^.stSeqCtrlGeneral.iInternalSeqStateCase OF
    0: // Check if enable
      IF TRUE
      AND THIS^.bEnable 
      THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 10; 
      ELSE
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF

    10: // Disable low pressure mode
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
			AND THIS^.itfTestCyl.M_LowPressureMode(bSet:= FALSE, ePressureType:= E_PRESSURE_TYPE.VALUE, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 20; 
			END_IF
      
    20: // Disable pump 2
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump2Add(bAdd:= FALSE)
      //AND THIS^.itfPump2Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 30; 
			END_IF
      
    30: // Disable pump 3
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump3Add(bAdd:= FALSE)
      //AND THIS^.itfPump3Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 40; 
			END_IF
      
    40: // Disable pump 4
      IF TRUE 
			AND THIS^.itfTestCyl.M_Pump4Add(bAdd:= FALSE)
      //AND THIS^.itfPump4Pressure.M_SetLimit(ePressureType:= E_PRESSURE_TYPE.PERCENT, rLimit:= 0)
			THEN
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; 
			END_IF
      
    50: // Vent cylinder - Choice step
      IF TRUE 
			THEN 
        IF THIS^.udiCurrentCycle > THIS^.uiVentCount THEN
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1000; 
        ELSE
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 60; 
				END_IF
			END_IF
      
    60: // Vent cylinder - Add low pressure circuit to counter cylinder
      IF TRUE 
			AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= TRUE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 70; 
			END_IF
      
    70: // Vent cylinder - Move to WP (Max position)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 5000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80; 
			END_IF
      
    80:	// Delay timer
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 81;
			END_IF
      
    81:	// Wait for HP endpos
      IF TRUE 
			THEN 
        IF TRUE 
        AND ABS(THIS^.itfTestCyl.P_PositionAbs - THIS^.lrLastPos) < 0.5
        THEN
          IF THIS^.bDoubleActing THEN
            THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 90;
          ELSE
            THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 91;
          END_IF
        ELSE
          THIS^.lrLastPos := THIS^.itfTestCyl.P_PositionAbs;
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 80;
        END_IF
			END_IF
      
    90: // Vent cylinder - Move to HP (Min position)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 10000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.FORCE, rWorkPressure:= 5000, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
			END_IF
      
    91: // Vent cylinder - Move to HP (Min position)
      IF TRUE
      AND THIS^.itfTestCyl.M_ToHP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 10, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 80)
      AND THIS^.itfCounterCyl.M_ToWP(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 200, eSpeedType:= E_SPEED_TYPE.PERCENT, rSpeed:= 100)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
			END_IF
      
    100:	// Delay timer
      IF TRUE 
      AND _m_Delay(DelayTime:= T#3S)
			THEN 
        THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 101;
			END_IF
      
    101:	// Wait for HP endpos
      IF TRUE 
			THEN 
        IF TRUE 
        AND ABS(THIS^.itfTestCyl.P_PositionAbs - THIS^.lrLastPos) < 0.5
        THEN
          THIS^.udiCurrentCycle := THIS^.udiCurrentCycle + 1;
				  THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 50; // Jump back
        ELSE
          THIS^.lrLastPos := THIS^.itfTestCyl.P_PositionAbs;
          THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 100;
        END_IF
			END_IF
      
    1000: // Exit seq - Disable low pressure circuit
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S)
      AND THIS^.itfCounterCyl.M_LowPressureCircuit(bAdd:= FALSE)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1010;
			END_IF  
    
    1010: // Exit seq - Stop
      IF TRUE
      AND _m_Delay(DelayTime:= T#1S) 
      AND THIS^.itfTestCyl.M_StopAndLock()
      AND THIS^.itfCounterCyl.M_Stop()
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 1020;
			END_IF
      
    1020: // Set pressure
      IF TRUE 
			AND THIS^.itfCounterCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
      AND THIS^.itfTestCyl.M_SetWorkPressure(ePressureType:= E_PRESSURE_TYPE.BAR, rWorkPressure:= 0)
			THEN 
				THIS^.stSeqCtrlGeneral.iInternalSeqStateCase := 9999; 
			END_IF
      
	ELSE
		THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.DONE;  
	END_CASE
	THIS^.stSeqCtrlGeneral.strExtraInfo:=concat('Internal state: ', TO_STRING(THIS^.stSeqCtrlGeneral.iInternalSeqStateCase));
E_SEQ_GENERAL.DONE:;
E_SEQ_GENERAL.ERROR:;
E_SEQ_GENERAL.TIME_OUT:; 

IF TRUE
AND THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit 
THEN
  THIS^.stSeqCtrlGeneral.strExtraInfo:= 'Bitte quittieren und erneut testen';
  IF TRUE
  //AND itfOpMode.P_QUIT
  THEN
    THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.EXECUTE;
	END_IF
  
END_IF

ELSE
  THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.ERROR;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_SequenceManager" Id="{7c1e1913-b60e-4599-83f0-d45de56e6073}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD PRIVATE _m_SequenceManager
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF FALSE
//AND THIS^.eActiveSeqState=DONE 
AND eLastSeq<>eSeq
THEN
	IF THIS^.stSeqCtrlGeneral.eActiveSeqState<>E_SEQ_GENERAL.EXECUTE THEN
		THIS^.stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.READY;
	END_IF
END_IF

eSeq := eNextSeq;

//DelayTimer und TimeOut Timer verwalten
stSeqCtrlGeneral.bActiveStep := TRUE
				                        AND eLastSeq = eSeq
				                        AND stSeqCtrlGeneral.eLastActiveSeqState = stSeqCtrlGeneral.eActiveSeqState
				                        AND	stSeqCtrlGeneral.iLastInternalSeqStateCase = stSeqCtrlGeneral.iInternalSeqStateCase;
			
IF NOT stSeqCtrlGeneral.bActiveStep THEN
	stSeqCtrlGeneral.bDelayActive:=FALSE;
	stSeqCtrlGeneral.bTimeOutActiveQuit:=FALSE;
	stSeqCtrlGeneral.bTimeOutActiveNoQuit:=FALSE;
  THIS^.stSeqCtrlGeneral.strExtraInfo:='';
END_IF

_m_SaveLastStep();
stSeqCtrlGeneral.tonDelay	(IN:=stSeqCtrlGeneral.bActiveStep AND stSeqCtrlGeneral.bDelayActive, 		PT:=stSeqCtrlGeneral.tDelay);
stSeqCtrlGeneral.tonTimeOut	(IN:=stSeqCtrlGeneral.bActiveStep AND (stSeqCtrlGeneral.bTimeOutActiveNoQuit OR stSeqCtrlGeneral.bTimeOutActiveQuit), 	PT:=stSeqCtrlGeneral.tTimeOut);
stSeqCtrlGeneral.tonStepTime	(IN:= stSeqCtrlGeneral.bActiveStep, PT:= T#24H);

IF stSeqCtrlGeneral.tonTimeOut.Q  THEN
	stSeqCtrlGeneral.eActiveSeqState:=E_SEQ_GENERAL.TIME_OUT;
END_IF

IF stSeqCtrlGeneral.iError<>0 THEN
	eSeq:=E_SEQ_PROCESS.ERROR_SEQ;
END_IF



eLastSeq					:=	eSeq;
stSeqCtrlGeneral.eLastActiveSeqState			:=	stSeqCtrlGeneral.eActiveSeqState;
stSeqCtrlGeneral.iLastInternalSeqStateCase	:=	stSeqCtrlGeneral.iInternalSeqStateCase;

// Reset set ready state
IF THIS^.stSeqCtrlGeneral.bExitSetReadyState THEN
  THIS^.stSeqCtrlGeneral.bExitSetReadyState := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_TimeOut" Id="{84ccee30-3d7a-44a7-b925-92ffd5cd9517}" FolderPath="PRIVAT\">
      <Declaration><![CDATA[METHOD PRIVATE _m_TimeOut : BOOL
VAR_INPUT
	bTimeoutActiveToQuit:	BOOL;
	bTimeOutActiveNoQuit:	BOOL;
	tTimeOut:				TIME;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stSeqCtrlGeneral.bTimeOutActiveQuit:=	bTimeoutActiveToQuit;
THIS^.stSeqCtrlGeneral.bTimeOutActiveNoQuit:=	bTimeOutActiveNoQuit;
THIS^.stSeqCtrlGeneral.tTimeOut:=			tTimeOut;
_m_TimeOut:=FALSE;
IF THIS^.stSeqCtrlGeneral.tonTimeOut.Q THEN
	_m_TimeOut:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{69f724b5-467b-4d82-9ffa-59f0d06670ad}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
  
  itfLogEvents: 										                      I_HANDLE_EVENTS;
  itfOpMode:											                        I_OP_MODE;
  itfTimer:                                               I_CLOCK; 
  itfCounterCyl:                                          I_CYLINDER_DA_COUNTER;
  itfTestCyl:                                             I_CYLINDER_DA_TESTDEV1;
  itfCounterCylPump:                                      I_PUMP_WITH_BYPASS;
  itfTestCylPump:                                         I_PUMP;
  itfPump2Pressure:                                       I_PRV_PROP;
  itfPump3Pressure:                                       I_PRV_PROP;
  itfPump4Pressure:                                       I_PRV_PROP;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.itfLogEvents := itfLogEvents;
THIS^.itfOpMode := itfOpMode;
THIS^.itfTimer := itfTimer;
THIS^.itfCounterCyl := itfCounterCyl;
THIS^.itfTestCyl := itfTestCyl;
THIS^.itfCounterCylPump := itfCounterCylPump;
THIS^.itfTestCylPump := itfTestCylPump;
THIS^.itfPump2Pressure := itfPump2Pressure;
THIS^.itfPump3Pressure := itfPump3Pressure;
THIS^.itfPump4Pressure := itfPump4Pressure;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_BreakPressureDet" Id="{74748da0-bd2c-49a2-814a-750be3253391}">
      <Declaration><![CDATA[METHOD M_BreakPressureDet : BOOL
VAR_INPUT
  stBreakPressureParams:                ST_RECIPE_BREAK_PRESSURE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_BreakPressureDet := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.stBPDParams := stBreakPressureParams;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.BREAK_PRESSURE_DET;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_EnduranceRun" Id="{d0f95853-b315-4486-8c4f-fc01bb6ca7bc}">
      <Declaration><![CDATA[METHOD M_EnduranceRun : BOOL
VAR_INPUT
  udiCycles:                            UDINT;
  stEnduranceRunParams:                 ST_RECIPE_ENDURANCE_RUN;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_EnduranceRun := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.udiERCycles := udiCycles;
THIS^.stERParams := stEnduranceRunParams;

// General
IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.ENDURANCE_RUN;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_LeakTest1" Id="{4f4e37fa-fd25-4dcf-9928-604f79cc073b}">
      <Declaration><![CDATA[METHOD M_LeakTest1 : BOOL
VAR_INPUT
  stLeakTest1Params:                 ST_RECIPE_LEAK_TEST1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_LeakTest1 := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.stLT1Params := stLeakTest1Params;

// General
IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.LEAK_TEST_1;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_LeakTest2" Id="{189fb586-e52b-47a2-a924-fdcc985ba5e5}">
      <Declaration><![CDATA[METHOD M_LeakTest2 : BOOL
VAR_INPUT
  stLeakTest2Params:                 ST_RECIPE_LEAK_TEST2;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_LeakTest2 := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.stLT2Params := stLeakTest2Params;

// General
IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.LEAK_TEST_2;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MaxSpeedRecord" Id="{5d3c1b8e-2502-43a8-8c28-d169977f645d}">
      <Declaration><![CDATA[METHOD M_MaxSpeedRecord : BOOL
VAR_INPUT 
  stEnduranceRunParams:                 ST_RECIPE_ENDURANCE_RUN;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MaxSpeedRecord := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.stERParams := stEnduranceRunParams;

// General
IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.MAX_SPEED_RECORD;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MeasureStrokeLength" Id="{c2d244be-0edd-4b3a-ab80-ba09bb0b94df}">
      <Declaration><![CDATA[METHOD M_MeasureStrokeLength : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MeasureStrokeLength := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.MEASURE_STROKE_LENGTH;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveToSetPos" Id="{59ea146f-29a2-4707-b219-d6a37656fe78}">
      <Declaration><![CDATA[METHOD M_MoveToSetPos : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MoveToSetPos := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.MOVE_TO_SET_POS;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{8d904b57-1c35-404d-b20a-fb02a0dc0b0c}">
      <Declaration><![CDATA[METHOD M_Reset : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_Reset := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.INIT;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Run" Id="{724e8203-b84b-428e-bc26-02f980cbae63}">
      <Declaration><![CDATA[{warning 'Methodenimplementierung hinzufügen'}
(*=== Method: M_Run  ============================================

 @brief: Here is the global code (Timer, Event, Flange,...)*)
METHOD M_Run
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SetEnableState" Id="{88f98aa6-af17-4b25-9464-be310f9fc189}">
      <Declaration><![CDATA[METHOD M_SetEnableState : BOOL
VAR_INPUT
	bEnable:        BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.bEnable := bEnable;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SetReady" Id="{8a7618e8-2d93-4866-a402-4bdca3e842c2}">
      <Declaration><![CDATA[METHOD M_SetReady : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_SetReady := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY;

THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.READY;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Stop" Id="{96ee87e0-486c-476e-9185-9dfde7315e1e}">
      <Declaration><![CDATA[METHOD M_Stop : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_Stop := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.STOP;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopEngine" Id="{2fa8e8fe-2d44-44b6-ba00-047c32a8206b}">
      <Declaration><![CDATA[METHOD M_StopEngine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_StopEngine := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.STOP_ENGINE;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_VentCylinder" Id="{315e753e-9ea7-42df-86ae-3907bd0ff162}">
      <Declaration><![CDATA[METHOD M_VentCylinder : BOOL
VAR_INPUT
  uiVentCount:                UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_VentCylinder := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.DONE;

// Assign input
THIS^.uiVentCount := uiVentCount;

// General
IF THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY THEN
  THIS^.eNextSeq := E_SEQ_PROCESS.VENT_CYLINDER;
  THIS^.stSeqCtrlGeneral.eActiveSeqState := E_SEQ_GENERAL.EXECUTE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_CurrentCycle" Id="{ff0b7470-a290-4887-9a48-05edf7daffda}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_CurrentCycle : UDINT
]]></Declaration>
      <Get Name="Get" Id="{1d5b16ba-da1c-42c3-8581-372c4d9c4ca7}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_CurrentCycle := THIS^.udiCurrentCycle;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_EnableState" Id="{73a142f6-adc4-4f02-b56b-701569ae4b60}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_EnableState : BOOL
]]></Declaration>
      <Get Name="Get" Id="{368995ee-cc1b-4cb1-a09a-4ec93cdbffae}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_EnableState := THIS^.bEnable;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_Event" Id="{978ddbed-454d-4d85-9c4d-55da2e1ee5c2}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
(*=== Property: P_Event  ============================================

 @param [set]: 	Set the Structure "ST_EVENT" from another Object
 @param [get]: 	Return the Structure "ST_EVENT", it contains the actual 
					event of the Object *)
PROPERTY P_Event : GenLib.ST_EVENT
]]></Declaration>
      <Get Name="Get" Id="{7d6b023e-6fdc-4621-acdd-bb381abd29a0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{097dc254-8d2a-4268-9edc-a5c53a685602}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_FullObjectPath" Id="{68b88692-c7ce-4675-bbca-69aaab218df9}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
(*=== Property: P_FullObjectPath  ============================================

 @param [set]: 	Set the Object Path (Clear String of Object)
 @param [get]: 	Return the Objectpath *)
PROPERTY P_FullObjectPath : STRING
]]></Declaration>
      <Get Name="Get" Id="{0bf57212-2bb4-4c1f-b343-bd965d09942f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{50e0ed5e-ae9c-4d33-9346-65de99b2d6a8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_Global_Ack" Id="{79c1ad3c-dffd-42ca-8b77-d6e61350bb82}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
(*=== Property: P_Global_Ack  ============================================

 @param [set]: 	Set the Bit for Ack from another Object
 @param [get]: 	Return the state of Ack Bit*)
PROPERTY P_Global_Ack : BOOL
]]></Declaration>
      <Get Name="Get" Id="{94ca851e-7acc-4895-a7d8-c75ddd88da8b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{655e623c-e84f-4964-b7ef-a4734057b68b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_GlobalID" Id="{e134d2c8-a091-4ef5-a10c-e2121ce16575}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
(*=== Property: P_GlobalID  ============================================

 @param [set]: 	-
 @param [get]: 	Return the string of instance path*)
PROPERTY P_GlobalID : STRING
]]></Declaration>
      <Get Name="Get" Id="{90c81d9c-df36-4ad2-a4e2-65ecb7405297}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_MaxSpeedInMmPerSHP" Id="{a17a401c-6b4a-4417-a71a-2bf3e6cdc976}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_MaxSpeedInMmPerSHP : REAL
]]></Declaration>
      <Get Name="Get" Id="{7ad7fa8e-1021-45ff-8ebc-2978df7fa724}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_MaxSpeedInMmPerSHP := THIS^.rMaxSpeedInMmPerSHP;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_MaxSpeedInMmPerSWP" Id="{5c6ed657-d30f-44c0-8792-53cdae061540}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_MaxSpeedInMmPerSWP : REAL
]]></Declaration>
      <Get Name="Get" Id="{da0ab197-eeec-4d05-81a7-e2e56ae7a74e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_MaxSpeedInMmPerSWP := THIS^.rMaxSpeedInMmPerSWP;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_ReadyState" Id="{68c34102-73ac-43a0-9b78-cab796a98916}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_ReadyState : BOOL
]]></Declaration>
      <Get Name="Get" Id="{bbf8f1cc-4537-47f6-9f42-35b4ea787681}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_ReadyState := THIS^.stSeqCtrlGeneral.eActiveSeqState = E_SEQ_GENERAL.READY;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_SerialNr" Id="{62999664-5397-4904-95aa-c3ebc4ad559b}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_SerialNr : STRING
]]></Declaration>
      <Get Name="Get" Id="{1c6680dd-57e0-40a7-ad3e-b62ff7a22a63}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_SerialNr := THIS^.strSerialNr;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{2e7a6c59-911d-4fd3-bfcc-bc2206635ca6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.strSerialNr := P_SerialNr;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_SpeedEfficiencyFactor" Id="{01b3cf73-427a-428d-8832-95418d10950e}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_SpeedEfficiencyFactor : REAL
]]></Declaration>
      <Get Name="Get" Id="{4d2ef226-3625-4f19-a1dd-e5b851aa9d97}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_SpeedEfficiencyFactor := THIS^.rSpeedEfficiencyFactor;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_Timer" Id="{67958d1a-7f5f-4a98-8849-3d0e9e1414c0}">
      <Declaration><![CDATA[{warning 'Eigenschaftenimplementierung hinzufügen'}
PROPERTY P_Timer : STRING
]]></Declaration>
      <Get Name="Get" Id="{d936384b-9516-45af-9eb6-6ebf4df0bc63}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_Timer := THIS^.sTimer;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="FB_SEQ_PROCESS_NEST1">
      <LineId Id="586" Count="0" />
      <LineId Id="629" Count="0" />
      <LineId Id="639" Count="0" />
      <LineId Id="919" Count="0" />
      <LineId Id="820" Count="0" />
      <LineId Id="819" Count="0" />
      <LineId Id="821" Count="1" />
      <LineId Id="918" Count="0" />
      <LineId Id="804" Count="2" />
      <LineId Id="811" Count="1" />
      <LineId Id="815" Count="1" />
      <LineId Id="814" Count="0" />
      <LineId Id="808" Count="0" />
      <LineId Id="826" Count="2" />
      <LineId Id="584" Count="1" />
      <LineId Id="169" Count="0" />
      <LineId Id="1013" Count="0" />
      <LineId Id="170" Count="5" />
      <LineId Id="352" Count="1" />
      <LineId Id="176" Count="4" />
      <LineId Id="189" Count="2" />
      <LineId Id="270" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="205" Count="0" />
      <LineId Id="287" Count="3" />
      <LineId Id="285" Count="0" />
      <LineId Id="283" Count="1" />
      <LineId Id="517" Count="3" />
      <LineId Id="282" Count="0" />
      <LineId Id="271" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="513" Count="3" />
      <LineId Id="281" Count="0" />
      <LineId Id="272" Count="0" />
      <LineId Id="265" Count="0" />
      <LineId Id="509" Count="3" />
      <LineId Id="273" Count="1" />
      <LineId Id="266" Count="0" />
      <LineId Id="505" Count="3" />
      <LineId Id="275" Count="1" />
      <LineId Id="268" Count="0" />
      <LineId Id="501" Count="3" />
      <LineId Id="279" Count="1" />
      <LineId Id="269" Count="0" />
      <LineId Id="497" Count="3" />
      <LineId Id="496" Count="0" />
      <LineId Id="720" Count="0" />
      <LineId Id="722" Count="4" />
      <LineId Id="721" Count="0" />
      <LineId Id="354" Count="5" />
      <LineId Id="263" Count="0" />
      <LineId Id="425" Count="0" />
      <LineId Id="427" Count="4" />
      <LineId Id="426" Count="0" />
      <LineId Id="360" Count="0" />
      <LineId Id="206" Count="2" />
      <LineId Id="350" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_DebugManager">
      <LineId Id="5" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="14" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Delay">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_GeneralStepSetting">
      <LineId Id="37" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="41" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_LeakTest1_LeakDet">
      <LineId Id="5" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="96" Count="7" />
      <LineId Id="82" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="106" Count="6" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="4" />
      <LineId Id="69" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="48" Count="6" />
      <LineId Id="17" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="56" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_LeakTest2_LeakDet">
      <LineId Id="5" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="96" Count="7" />
      <LineId Id="82" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="106" Count="6" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="4" />
      <LineId Id="69" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="130" Count="1" />
      <LineId Id="133" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="139" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="48" Count="5" />
      <LineId Id="153" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="56" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_ResetDelayTimer">
      <LineId Id="11" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_SaveLastStep">
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="24" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_BREAK_PRESSURE_DET">
      <LineId Id="84" Count="12" />
      <LineId Id="260" Count="0" />
      <LineId Id="97" Count="1" />
      <LineId Id="258" Count="0" />
      <LineId Id="104" Count="2" />
      <LineId Id="259" Count="0" />
      <LineId Id="107" Count="1" />
      <LineId Id="501" Count="6" />
      <LineId Id="403" Count="0" />
      <LineId Id="500" Count="0" />
      <LineId Id="499" Count="0" />
      <LineId Id="404" Count="3" />
      <LineId Id="401" Count="0" />
      <LineId Id="463" Count="0" />
      <LineId Id="465" Count="20" />
      <LineId Id="513" Count="0" />
      <LineId Id="486" Count="0" />
      <LineId Id="514" Count="2" />
      <LineId Id="464" Count="0" />
      <LineId Id="415" Count="0" />
      <LineId Id="288" Count="1" />
      <LineId Id="295" Count="0" />
      <LineId Id="290" Count="0" />
      <LineId Id="492" Count="1" />
      <LineId Id="291" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="427" Count="0" />
      <LineId Id="429" Count="1" />
      <LineId Id="432" Count="2" />
      <LineId Id="451" Count="6" />
      <LineId Id="297" Count="0" />
      <LineId Id="294" Count="0" />
      <LineId Id="170" Count="1" />
      <LineId Id="304" Count="0" />
      <LineId Id="306" Count="0" />
      <LineId Id="172" Count="1" />
      <LineId Id="240" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="262" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="272" Count="1" />
      <LineId Id="418" Count="0" />
      <LineId Id="275" Count="2" />
      <LineId Id="279" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="201" Count="1" />
      <LineId Id="307" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="420" Count="0" />
      <LineId Id="231" Count="0" />
      <LineId Id="233" Count="2" />
      <LineId Id="237" Count="1" />
      <LineId Id="242" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="310" Count="4" />
      <LineId Id="309" Count="0" />
      <LineId Id="315" Count="0" />
      <LineId Id="317" Count="0" />
      <LineId Id="349" Count="3" />
      <LineId Id="354" Count="8" />
      <LineId Id="323" Count="0" />
      <LineId Id="517" Count="2" />
      <LineId Id="522" Count="0" />
      <LineId Id="526" Count="0" />
      <LineId Id="523" Count="0" />
      <LineId Id="520" Count="0" />
      <LineId Id="527" Count="1" />
      <LineId Id="539" Count="1" />
      <LineId Id="608" Count="0" />
      <LineId Id="541" Count="4" />
      <LineId Id="553" Count="4" />
      <LineId Id="559" Count="3" />
      <LineId Id="571" Count="36" />
      <LineId Id="530" Count="0" />
      <LineId Id="388" Count="0" />
      <LineId Id="365" Count="3" />
      <LineId Id="416" Count="0" />
      <LineId Id="370" Count="1" />
      <LineId Id="380" Count="7" />
      <LineId Id="364" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="141" Count="23" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_ENDURANCE_RUN">
      <LineId Id="17" Count="12" />
      <LineId Id="216" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="438" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="38" Count="1" />
      <LineId Id="215" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="486" Count="1" />
      <LineId Id="489" Count="0" />
      <LineId Id="491" Count="3" />
      <LineId Id="490" Count="0" />
      <LineId Id="488" Count="0" />
      <LineId Id="332" Count="3" />
      <LineId Id="473" Count="0" />
      <LineId Id="478" Count="0" />
      <LineId Id="480" Count="0" />
      <LineId Id="479" Count="0" />
      <LineId Id="474" Count="0" />
      <LineId Id="476" Count="1" />
      <LineId Id="475" Count="0" />
      <LineId Id="390" Count="0" />
      <LineId Id="396" Count="0" />
      <LineId Id="398" Count="2" />
      <LineId Id="441" Count="0" />
      <LineId Id="401" Count="1" />
      <LineId Id="397" Count="0" />
      <LineId Id="424" Count="0" />
      <LineId Id="426" Count="2" />
      <LineId Id="442" Count="0" />
      <LineId Id="429" Count="1" />
      <LineId Id="425" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="433" Count="2" />
      <LineId Id="443" Count="0" />
      <LineId Id="436" Count="1" />
      <LineId Id="432" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="330" Count="0" />
      <LineId Id="169" Count="1" />
      <LineId Id="209" Count="0" />
      <LineId Id="454" Count="0" />
      <LineId Id="452" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="212" Count="1" />
      <LineId Id="211" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="184" Count="2" />
      <LineId Id="188" Count="1" />
      <LineId Id="246" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="310" Count="6" />
      <LineId Id="309" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="176" Count="1" />
      <LineId Id="217" Count="0" />
      <LineId Id="455" Count="2" />
      <LineId Id="180" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="358" Count="0" />
      <LineId Id="360" Count="1" />
      <LineId Id="363" Count="0" />
      <LineId Id="458" Count="2" />
      <LineId Id="364" Count="1" />
      <LineId Id="201" Count="0" />
      <LineId Id="551" Count="0" />
      <LineId Id="553" Count="0" />
      <LineId Id="558" Count="4" />
      <LineId Id="552" Count="0" />
      <LineId Id="289" Count="0" />
      <LineId Id="291" Count="1" />
      <LineId Id="307" Count="0" />
      <LineId Id="293" Count="3" />
      <LineId Id="290" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="194" Count="1" />
      <LineId Id="197" Count="0" />
      <LineId Id="461" Count="2" />
      <LineId Id="198" Count="0" />
      <LineId Id="523" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="525" Count="1" />
      <LineId Id="524" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="372" Count="1" />
      <LineId Id="375" Count="0" />
      <LineId Id="464" Count="2" />
      <LineId Id="376" Count="0" />
      <LineId Id="563" Count="0" />
      <LineId Id="371" Count="0" />
      <LineId Id="527" Count="0" />
      <LineId Id="529" Count="6" />
      <LineId Id="545" Count="0" />
      <LineId Id="528" Count="0" />
      <LineId Id="564" Count="0" />
      <LineId Id="566" Count="0" />
      <LineId Id="571" Count="6" />
      <LineId Id="565" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="339" Count="5" />
      <LineId Id="338" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="221" Count="5" />
      <LineId Id="228" Count="0" />
      <LineId Id="236" Count="1" />
      <LineId Id="239" Count="5" />
      <LineId Id="73" Count="0" />
      <LineId Id="403" Count="0" />
      <LineId Id="405" Count="4" />
      <LineId Id="404" Count="0" />
      <LineId Id="410" Count="0" />
      <LineId Id="412" Count="4" />
      <LineId Id="411" Count="0" />
      <LineId Id="417" Count="0" />
      <LineId Id="419" Count="3" />
      <LineId Id="511" Count="2" />
      <LineId Id="510" Count="0" />
      <LineId Id="423" Count="0" />
      <LineId Id="514" Count="2" />
      <LineId Id="418" Count="0" />
      <LineId Id="500" Count="0" />
      <LineId Id="502" Count="1" />
      <LineId Id="508" Count="1" />
      <LineId Id="504" Count="0" />
      <LineId Id="506" Count="1" />
      <LineId Id="501" Count="0" />
      <LineId Id="288" Count="0" />
      <LineId Id="74" Count="3" />
      <LineId Id="467" Count="0" />
      <LineId Id="78" Count="19" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_INIT">
      <LineId Id="45" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="151" Count="1" />
      <LineId Id="229" Count="0" />
      <LineId Id="153" Count="1" />
      <LineId Id="191" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="158" Count="4" />
      <LineId Id="205" Count="0" />
      <LineId Id="250" Count="0" />
      <LineId Id="252" Count="21" />
      <LineId Id="251" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="73" Count="3" />
      <LineId Id="136" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="212" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="282" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="288" Count="2" />
      <LineId Id="283" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="14" Count="2" />
      <LineId Id="119" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="116" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="123" Count="1" />
      <LineId Id="122" Count="0" />
      <LineId Id="114" Count="1" />
      <LineId Id="112" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="127" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_LEAK_TEST_1">
      <LineId Id="8" Count="12" />
      <LineId Id="95" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="236" Count="0" />
      <LineId Id="28" Count="2" />
      <LineId Id="94" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="600" Count="6" />
      <LineId Id="96" Count="0" />
      <LineId Id="599" Count="0" />
      <LineId Id="598" Count="0" />
      <LineId Id="97" Count="3" />
      <LineId Id="113" Count="6" />
      <LineId Id="128" Count="0" />
      <LineId Id="551" Count="0" />
      <LineId Id="553" Count="20" />
      <LineId Id="612" Count="0" />
      <LineId Id="574" Count="0" />
      <LineId Id="613" Count="2" />
      <LineId Id="552" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="147" Count="7" />
      <LineId Id="163" Count="0" />
      <LineId Id="616" Count="0" />
      <LineId Id="618" Count="7" />
      <LineId Id="617" Count="0" />
      <LineId Id="164" Count="7" />
      <LineId Id="180" Count="0" />
      <LineId Id="499" Count="0" />
      <LineId Id="501" Count="1" />
      <LineId Id="504" Count="0" />
      <LineId Id="506" Count="1" />
      <LineId Id="500" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="243" Count="1" />
      <LineId Id="251" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="580" Count="2" />
      <LineId Id="247" Count="1" />
      <LineId Id="253" Count="0" />
      <LineId Id="659" Count="0" />
      <LineId Id="661" Count="0" />
      <LineId Id="667" Count="0" />
      <LineId Id="693" Count="0" />
      <LineId Id="668" Count="1" />
      <LineId Id="685" Count="0" />
      <LineId Id="691" Count="0" />
      <LineId Id="288" Count="2" />
      <LineId Id="292" Count="2" />
      <LineId Id="296" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="272" Count="3" />
      <LineId Id="583" Count="2" />
      <LineId Id="276" Count="1" />
      <LineId Id="279" Count="0" />
      <LineId Id="694" Count="0" />
      <LineId Id="714" Count="4" />
      <LineId Id="695" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="305" Count="4" />
      <LineId Id="626" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="627" Count="2" />
      <LineId Id="304" Count="0" />
      <LineId Id="181" Count="5" />
      <LineId Id="268" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="261" Count="0" />
      <LineId Id="630" Count="0" />
      <LineId Id="632" Count="7" />
      <LineId Id="631" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="385" Count="6" />
      <LineId Id="384" Count="0" />
      <LineId Id="516" Count="0" />
      <LineId Id="518" Count="4" />
      <LineId Id="517" Count="0" />
      <LineId Id="319" Count="0" />
      <LineId Id="321" Count="3" />
      <LineId Id="586" Count="2" />
      <LineId Id="325" Count="1" />
      <LineId Id="335" Count="0" />
      <LineId Id="719" Count="0" />
      <LineId Id="721" Count="4" />
      <LineId Id="720" Count="0" />
      <LineId Id="336" Count="6" />
      <LineId Id="351" Count="5" />
      <LineId Id="589" Count="2" />
      <LineId Id="357" Count="1" />
      <LineId Id="367" Count="0" />
      <LineId Id="726" Count="0" />
      <LineId Id="728" Count="4" />
      <LineId Id="727" Count="0" />
      <LineId Id="368" Count="5" />
      <LineId Id="640" Count="0" />
      <LineId Id="374" Count="0" />
      <LineId Id="641" Count="2" />
      <LineId Id="320" Count="0" />
      <LineId Id="400" Count="0" />
      <LineId Id="402" Count="7" />
      <LineId Id="418" Count="0" />
      <LineId Id="644" Count="0" />
      <LineId Id="646" Count="7" />
      <LineId Id="645" Count="0" />
      <LineId Id="419" Count="7" />
      <LineId Id="435" Count="0" />
      <LineId Id="531" Count="0" />
      <LineId Id="533" Count="4" />
      <LineId Id="532" Count="0" />
      <LineId Id="436" Count="4" />
      <LineId Id="592" Count="2" />
      <LineId Id="441" Count="1" />
      <LineId Id="451" Count="0" />
      <LineId Id="733" Count="0" />
      <LineId Id="735" Count="4" />
      <LineId Id="734" Count="0" />
      <LineId Id="452" Count="6" />
      <LineId Id="467" Count="5" />
      <LineId Id="595" Count="2" />
      <LineId Id="473" Count="1" />
      <LineId Id="483" Count="0" />
      <LineId Id="740" Count="0" />
      <LineId Id="742" Count="4" />
      <LineId Id="741" Count="0" />
      <LineId Id="484" Count="6" />
      <LineId Id="401" Count="0" />
      <LineId Id="192" Count="6" />
      <LineId Id="207" Count="8" />
      <LineId Id="224" Count="7" />
      <LineId Id="63" Count="25" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_LEAK_TEST_2">
      <LineId Id="97" Count="15" />
      <LineId Id="117" Count="6" />
      <LineId Id="628" Count="6" />
      <LineId Id="124" Count="0" />
      <LineId Id="627" Count="0" />
      <LineId Id="626" Count="0" />
      <LineId Id="125" Count="3" />
      <LineId Id="569" Count="0" />
      <LineId Id="561" Count="0" />
      <LineId Id="563" Count="4" />
      <LineId Id="137" Count="0" />
      <LineId Id="597" Count="0" />
      <LineId Id="599" Count="21" />
      <LineId Id="598" Count="0" />
      <LineId Id="138" Count="4" />
      <LineId Id="640" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="641" Count="2" />
      <LineId Id="152" Count="9" />
      <LineId Id="170" Count="8" />
      <LineId Id="187" Count="4" />
      <LineId Id="698" Count="0" />
      <LineId Id="192" Count="1" />
      <LineId Id="202" Count="5" />
      <LineId Id="645" Count="2" />
      <LineId Id="208" Count="1" />
      <LineId Id="691" Count="0" />
      <LineId Id="671" Count="0" />
      <LineId Id="673" Count="2" />
      <LineId Id="679" Count="2" />
      <LineId Id="672" Count="0" />
      <LineId Id="657" Count="0" />
      <LineId Id="659" Count="4" />
      <LineId Id="658" Count="0" />
      <LineId Id="219" Count="6" />
      <LineId Id="266" Count="9" />
      <LineId Id="284" Count="8" />
      <LineId Id="301" Count="4" />
      <LineId Id="699" Count="0" />
      <LineId Id="306" Count="1" />
      <LineId Id="316" Count="5" />
      <LineId Id="648" Count="2" />
      <LineId Id="322" Count="1" />
      <LineId Id="332" Count="0" />
      <LineId Id="682" Count="0" />
      <LineId Id="684" Count="5" />
      <LineId Id="683" Count="0" />
      <LineId Id="664" Count="0" />
      <LineId Id="666" Count="4" />
      <LineId Id="665" Count="0" />
      <LineId Id="333" Count="6" />
      <LineId Id="494" Count="7" />
      <LineId Id="510" Count="8" />
      <LineId Id="527" Count="7" />
      <LineId Id="577" Count="0" />
      <LineId Id="584" Count="0" />
      <LineId Id="586" Count="1" />
      <LineId Id="589" Count="2" />
      <LineId Id="585" Count="0" />
      <LineId Id="536" Count="24" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_MAX_SPEED_RECORD">
      <LineId Id="473" Count="18" />
      <LineId Id="713" Count="1" />
      <LineId Id="492" Count="7" />
      <LineId Id="758" Count="0" />
      <LineId Id="500" Count="9" />
      <LineId Id="517" Count="0" />
      <LineId Id="542" Count="0" />
      <LineId Id="806" Count="0" />
      <LineId Id="808" Count="4" />
      <LineId Id="807" Count="0" />
      <LineId Id="781" Count="0" />
      <LineId Id="783" Count="6" />
      <LineId Id="825" Count="0" />
      <LineId Id="790" Count="0" />
      <LineId Id="826" Count="2" />
      <LineId Id="791" Count="9" />
      <LineId Id="782" Count="0" />
      <LineId Id="829" Count="0" />
      <LineId Id="831" Count="7" />
      <LineId Id="830" Count="0" />
      <LineId Id="862" Count="0" />
      <LineId Id="864" Count="0" />
      <LineId Id="869" Count="4" />
      <LineId Id="863" Count="0" />
      <LineId Id="804" Count="0" />
      <LineId Id="813" Count="6" />
      <LineId Id="805" Count="0" />
      <LineId Id="543" Count="11" />
      <LineId Id="562" Count="30" />
      <LineId Id="700" Count="0" />
      <LineId Id="702" Count="0" />
      <LineId Id="707" Count="0" />
      <LineId Id="712" Count="0" />
      <LineId Id="708" Count="0" />
      <LineId Id="715" Count="0" />
      <LineId Id="717" Count="0" />
      <LineId Id="716" Count="0" />
      <LineId Id="718" Count="0" />
      <LineId Id="756" Count="1" />
      <LineId Id="709" Count="0" />
      <LineId Id="701" Count="0" />
      <LineId Id="719" Count="0" />
      <LineId Id="721" Count="1" />
      <LineId Id="728" Count="1" />
      <LineId Id="720" Count="0" />
      <LineId Id="593" Count="16" />
      <LineId Id="841" Count="0" />
      <LineId Id="610" Count="0" />
      <LineId Id="842" Count="2" />
      <LineId Id="611" Count="9" />
      <LineId Id="622" Count="2" />
      <LineId Id="845" Count="0" />
      <LineId Id="847" Count="9" />
      <LineId Id="846" Count="0" />
      <LineId Id="743" Count="0" />
      <LineId Id="745" Count="7" />
      <LineId Id="755" Count="0" />
      <LineId Id="754" Count="0" />
      <LineId Id="753" Count="0" />
      <LineId Id="744" Count="0" />
      <LineId Id="730" Count="0" />
      <LineId Id="732" Count="1" />
      <LineId Id="739" Count="2" />
      <LineId Id="731" Count="0" />
      <LineId Id="759" Count="3" />
      <LineId Id="764" Count="0" />
      <LineId Id="766" Count="1" />
      <LineId Id="769" Count="4" />
      <LineId Id="775" Count="1" />
      <LineId Id="774" Count="0" />
      <LineId Id="768" Count="0" />
      <LineId Id="765" Count="0" />
      <LineId Id="777" Count="1" />
      <LineId Id="780" Count="0" />
      <LineId Id="779" Count="0" />
      <LineId Id="763" Count="0" />
      <LineId Id="625" Count="74" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_MEASURE_STROKE_LENGTH">
      <LineId Id="6" Count="4" />
      <LineId Id="12" Count="6" />
      <LineId Id="175" Count="0" />
      <LineId Id="19" Count="2" />
      <LineId Id="173" Count="0" />
      <LineId Id="26" Count="2" />
      <LineId Id="174" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="385" Count="2" />
      <LineId Id="435" Count="0" />
      <LineId Id="388" Count="1" />
      <LineId Id="193" Count="0" />
      <LineId Id="405" Count="0" />
      <LineId Id="407" Count="21" />
      <LineId Id="406" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="133" Count="4" />
      <LineId Id="139" Count="1" />
      <LineId Id="84" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="272" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="203" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="206" Count="1" />
      <LineId Id="202" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="219" Count="1" />
      <LineId Id="227" Count="0" />
      <LineId Id="223" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="363" Count="0" />
      <LineId Id="365" Count="1" />
      <LineId Id="368" Count="6" />
      <LineId Id="376" Count="0" />
      <LineId Id="375" Count="0" />
      <LineId Id="257" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="242" Count="2" />
      <LineId Id="246" Count="1" />
      <LineId Id="392" Count="0" />
      <LineId Id="273" Count="0" />
      <LineId Id="275" Count="5" />
      <LineId Id="157" Count="0" />
      <LineId Id="289" Count="0" />
      <LineId Id="291" Count="3" />
      <LineId Id="301" Count="0" />
      <LineId Id="290" Count="0" />
      <LineId Id="349" Count="0" />
      <LineId Id="351" Count="1" />
      <LineId Id="354" Count="6" />
      <LineId Id="362" Count="0" />
      <LineId Id="361" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="312" Count="4" />
      <LineId Id="318" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="327" Count="5" />
      <LineId Id="334" Count="0" />
      <LineId Id="341" Count="0" />
      <LineId Id="343" Count="5" />
      <LineId Id="342" Count="0" />
      <LineId Id="442" Count="0" />
      <LineId Id="444" Count="1" />
      <LineId Id="447" Count="2" />
      <LineId Id="443" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="438" Count="3" />
      <LineId Id="437" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="57" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_MOVE_TO_SET_POS">
      <LineId Id="8" Count="12" />
      <LineId Id="95" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="27" Count="3" />
      <LineId Id="94" Count="0" />
      <LineId Id="31" Count="32" />
      <LineId Id="101" Count="0" />
      <LineId Id="103" Count="3" />
      <LineId Id="102" Count="0" />
      <LineId Id="64" Count="24" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_STOP">
      <LineId Id="6" Count="4" />
      <LineId Id="12" Count="2" />
      <LineId Id="16" Count="2" />
      <LineId Id="295" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="302" Count="0" />
      <LineId Id="292" Count="2" />
      <LineId Id="28" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="184" Count="7" />
      <LineId Id="204" Count="4" />
      <LineId Id="217" Count="3" />
      <LineId Id="222" Count="3" />
      <LineId Id="170" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="307" Count="0" />
      <LineId Id="313" Count="4" />
      <LineId Id="306" Count="0" />
      <LineId Id="318" Count="0" />
      <LineId Id="320" Count="5" />
      <LineId Id="319" Count="0" />
      <LineId Id="326" Count="0" />
      <LineId Id="328" Count="5" />
      <LineId Id="327" Count="0" />
      <LineId Id="340" Count="0" />
      <LineId Id="342" Count="3" />
      <LineId Id="341" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="57" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_STOP_ENGINE">
      <LineId Id="145" Count="8" />
      <LineId Id="155" Count="5" />
      <LineId Id="164" Count="5" />
      <LineId Id="234" Count="18" />
      <LineId Id="200" Count="0" />
      <LineId Id="261" Count="0" />
      <LineId Id="263" Count="3" />
      <LineId Id="262" Count="0" />
      <LineId Id="201" Count="24" />
      <LineId Id="127" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_Seq_VENT_CYLINDER">
      <LineId Id="6" Count="4" />
      <LineId Id="12" Count="6" />
      <LineId Id="295" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="290" Count="0" />
      <LineId Id="292" Count="2" />
      <LineId Id="28" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="430" Count="6" />
      <LineId Id="359" Count="0" />
      <LineId Id="429" Count="0" />
      <LineId Id="428" Count="0" />
      <LineId Id="360" Count="0" />
      <LineId Id="391" Count="0" />
      <LineId Id="361" Count="2" />
      <LineId Id="184" Count="0" />
      <LineId Id="398" Count="0" />
      <LineId Id="400" Count="21" />
      <LineId Id="399" Count="0" />
      <LineId Id="364" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="195" Count="13" />
      <LineId Id="217" Count="3" />
      <LineId Id="222" Count="4" />
      <LineId Id="302" Count="0" />
      <LineId Id="304" Count="12" />
      <LineId Id="443" Count="0" />
      <LineId Id="317" Count="0" />
      <LineId Id="444" Count="2" />
      <LineId Id="318" Count="3" />
      <LineId Id="234" Count="3" />
      <LineId Id="239" Count="3" />
      <LineId Id="260" Count="0" />
      <LineId Id="447" Count="0" />
      <LineId Id="449" Count="5" />
      <LineId Id="448" Count="0" />
      <LineId Id="330" Count="0" />
      <LineId Id="332" Count="13" />
      <LineId Id="350" Count="0" />
      <LineId Id="346" Count="3" />
      <LineId Id="331" Count="0" />
      <LineId Id="261" Count="0" />
      <LineId Id="375" Count="1" />
      <LineId Id="379" Count="3" />
      <LineId Id="384" Count="0" />
      <LineId Id="374" Count="0" />
      <LineId Id="262" Count="6" />
      <LineId Id="277" Count="7" />
      <LineId Id="170" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="57" Count="21" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_SequenceManager">
      <LineId Id="14" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="49" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="69" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="23" Count="11" />
      <LineId Id="59" Count="4" />
      <LineId Id="5" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="78" Count="2" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1._m_TimeOut">
      <LineId Id="8" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="9" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.FB_init">
      <LineId Id="7" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="53" Count="1" />
      <LineId Id="70" Count="2" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_BreakPressureDet">
      <LineId Id="7" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_EnduranceRun">
      <LineId Id="7" Count="0" />
      <LineId Id="73" Count="1" />
      <LineId Id="94" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_LeakTest1">
      <LineId Id="7" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_LeakTest2">
      <LineId Id="7" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="58" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_MaxSpeedRecord">
      <LineId Id="7" Count="0" />
      <LineId Id="51" Count="1" />
      <LineId Id="54" Count="1" />
      <LineId Id="8" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_MeasureStrokeLength">
      <LineId Id="7" Count="1" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_MoveToSetPos">
      <LineId Id="7" Count="1" />
      <LineId Id="44" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_Reset">
      <LineId Id="7" Count="1" />
      <LineId Id="56" Count="2" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_Run">
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_SetEnableState">
      <LineId Id="7" Count="1" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_SetReady">
      <LineId Id="26" Count="1" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_Stop">
      <LineId Id="5" Count="4" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_StopEngine">
      <LineId Id="7" Count="4" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.M_VentCylinder">
      <LineId Id="6" Count="0" />
      <LineId Id="47" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="53" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_CurrentCycle.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_EnableState.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_Event.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_Event.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_FullObjectPath.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_FullObjectPath.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_Global_Ack.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_Global_Ack.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_GlobalID.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_MaxSpeedInMmPerSHP.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_MaxSpeedInMmPerSWP.Get">
      <LineId Id="5" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_ReadyState.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_SerialNr.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_SerialNr.Set">
      <LineId Id="5" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_SpeedEfficiencyFactor.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SEQ_PROCESS_NEST1.P_Timer.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>